import groovy.io.FileType

plugins {
    id "groovy"
    id "idea"
}

repositories {
    jcenter()
}

dependencies {
    testImplementation gradleTestKit()
    testImplementation localGroovy()
    testImplementation("org.spockframework:spock-core:1.1-groovy-2.4") {
        exclude group: "org.codehaus.groovy"
    }
}

test {
    inputs.files files("../swift", '../cpp').asFileTree.matching { PatternFilterable pattern ->
        pattern.exclude "**/build", "**/.gradle", "**/*.xcworkspace", "**/*.xcodeproj", "**/repo"
    }
}

task cleanRepo(type: Delete) {
    delete file("../cpp/repo")
}

task cleanSamples {
    dependsOn cleanRepo
    doLast {
        def toDelete = []
        [file("../swift"), file("../cpp")]*.eachFileRecurse(FileType.DIRECTORIES) { def dir ->
            if ([/repo/, /build/, /\.gradle/, /.+\.xcworkspace/, /.+\.xcodeproj/].any { dir.name ==~ it }) {
                toDelete << dir
            }
        }
        toDelete.each { it.deleteDir() }
    }
}

clean.dependsOn cleanSamples

task configureNightlyWrapper {
    doLast {
        configure(tasks.nightlyWrapper) {
            def version = new groovy.json.JsonSlurper().parseText(new URL("https://services.gradle.org/versions/nightly").text)
            if (version.empty) {
                throw new GradleException("Cannot update wrapper to 'nightly' version as there is currently no version of that label")
            }
            println "updating wrapper to nightly version: $version.version (downloadUrl: $version.downloadUrl)"
            distributionUrl version.downloadUrl
        }
    }
}

task nightlyWrapper(type: Wrapper) {
    dependsOn configureNightlyWrapper
    group = "wrapper"
    scriptFile = "../gradlew"
    jarFile = "../gradle/wrapper/gradle-wrapper.jar"
}

tasks.withType(SourceCopyTask) {
    templatesDir = file("src/templates")
    group = "source generation"
}

task generateSource {
    dependsOn tasks.withType(SourceCopyTask)
    group = "source generation"
}

task cppTransitiveDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/transitive-dependencies")

    copyToAppProject("cpp-app", "app")
    copyToLibProject("cpp-lib-with-api-dep", "utilities")
    copyToLibProject("cpp-lib", "list")
}

task cppApplication(type: SourceCopyTask) {
    sampleDir = file("../cpp/application")

    copyToAppProject("cpp-app", ".")
    copyToAppProject("cpp-lib-with-api-dep", ".")
    copyToAppProject("cpp-lib", ".")
}

task cppLibrary(type: SourceCopyTask) {
    sampleDir = file("../cpp/simple-library")

    copyToLibProject("cpp-lib", ".")
}

task cppBinaryDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/binary-dependencies")

    copyToAppProject("cpp-app", ".")
    copyToAppProject("cpp-lib-with-api-dep", ".")
}

task cppPrebuiltBinaries(type: SourceCopyTask) {
    sampleDir = file("../cpp/prebuilt-binaries")

    copyToAppProject("cpp-app", ".")
    copyToAppProject("cpp-lib-with-api-dep", ".")
}

task cppCompositeBuild(type: SourceCopyTask) {
    sampleDir = file("../cpp/composite-build")

    copyToAppProject("cpp-app", ".")
    copyToLibProject("cpp-lib-with-api-dep", "utilities-library")
    copyToLibProject("cpp-lib", "list-library")
}

class SourceCopyTask extends DefaultTask {
    final DirectoryProperty sampleDir = project.layout.directoryProperty()
    final DirectoryProperty templatesDir = project.layout.directoryProperty()
    private final List<TemplateTarget> templates = []

    @TaskAction
    def go() {
        def cleaned = new HashSet()
        templates.each { t ->
            def templateBaseDir = templatesDir.dir(t.template).get().asFile
            def projectDir = sampleDir.dir(t.projectDir).get().asFile
            t.visitDirs { s, d ->
                def srcDir = new File(templateBaseDir, s)
                if (!srcDir.directory) {
                    return
                }
                def destDir = new File(projectDir, d)
                println "copy $srcDir to $destDir"
                if (cleaned.add(destDir)) {
                    project.delete(destDir)
                }
                project.copy {
                    from srcDir
                    into destDir
                }
            }
        }
    }

    void copyToAppProject(String template, String projectDir) {
        templates.add(new AppTarget(template, projectDir))
    }

    void copyToLibProject(String template, String projectDir) {
        templates.add(new LibTarget(template, projectDir))
    }

    static abstract class TemplateTarget {
        final String template
        final String projectDir

        TemplateTarget(String template, String projectDir) {
            this.template = template
            this.projectDir = projectDir
        }

        abstract void visitDirs(Closure cl)
    }

    static class AppTarget extends TemplateTarget {
        AppTarget(String template, String projectDir) {
            super(template, projectDir)
        }

        @Override
        void visitDirs(Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp")
            cl.call("src/main/headers", "src/main/headers")
            cl.call("src/main/public", "src/main/headers")
        }
    }

    static class LibTarget extends TemplateTarget {
        LibTarget(String template, String projectDir) {
            super(template, projectDir)
        }

        @Override
        void visitDirs(Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp")
            cl.call("src/main/headers", "src/main/headers")
            cl.call("src/main/public", "src/main/public")
        }
    }
}
