import groovy.io.FileType
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.InitCommand

buildscript {
    dependencies {
        classpath "org.eclipse.jgit:org.eclipse.jgit:4.9.1.201712030800-r"
    }
}

plugins {
    id "groovy"
    id "idea"
}

repositories {
    jcenter()
}

dependencies {
    testImplementation gradleTestKit()
    testImplementation localGroovy()
    testImplementation("org.spockframework:spock-core:1.1-groovy-2.4") {
        exclude group: "org.codehaus.groovy"
    }
    testImplementation "com.atlassian.commonmark:commonmark:0.10.0"
}

test {
    dependsOn "generateCppRepos", "generateSwiftRepos"
    inputs.files files("../swift", '../cpp').asFileTree.matching { PatternFilterable pattern ->
        pattern.exclude "**/build", "**/.gradle", "**/*.xcworkspace", "**/*.xcodeproj", "**/repo"
    }
}

task cleanRepo(type: Delete) {
    delete file("../cpp/repo")
}

task cleanSamples {
    dependsOn cleanRepo
    doLast {
        def toDelete = []
        [file("../swift"), file("../cpp")]*.eachFileRecurse(FileType.DIRECTORIES) { def dir ->
            if ([/repo/, /build/, /\.gradle/, /\.build/, /.+\.xcworkspace/, /.+\.xcodeproj/].any { dir.name ==~ it }) {
                toDelete << dir
            }
        }
        toDelete.each { it.deleteDir() }
    }
}

clean.dependsOn cleanSamples, cleanRepo

task configureNightlyWrapper {
    doLast {
        configure(tasks.nightlyWrapper) {
            def version = new groovy.json.JsonSlurper().parseText(new URL("https://services.gradle.org/versions/nightly").text)
            if (version.empty) {
                throw new GradleException("Cannot update wrapper to 'nightly' version as there is currently no version of that label")
            }
            println "updating wrapper to nightly version: $version.version (downloadUrl: $version.downloadUrl)"
            distributionUrl version.downloadUrl
        }
    }
}

task nightlyWrapper(type: Wrapper) {
    dependsOn configureNightlyWrapper
    group = "wrapper"
    description = "Updates the samples to use the most recent nightly"
    scriptFile = "../gradlew"
    jarFile = "../gradle/wrapper/gradle-wrapper.jar"
}

tasks.withType(SourceCopyTask) {
    templatesDir = file("src/templates")
    group = "source generation"
}

task generateSource {
    dependsOn tasks.withType(SourceCopyTask)
    group = "source generation"
    description = "generate the source files for all samples"
}

def cppUtilsLib = CppLibraryTemplate.of("cpp-lib-with-api-dep", "utilities")
def cppListLib = CppLibraryTemplate.of("cpp-lib", "list")

def swiftUtilsLib = SwiftLibraryTemplate.of("swift-lib-with-api-dep", "Utilities")
def swiftListLib = SwiftLibraryTemplate.of("swift-lib", "List")

task cppTransitiveDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/transitive-dependencies")

    appProject("app").fromTemplate("cpp-app")
    libProject("utilities").fromTemplate(cppUtilsLib)
    libProject("list").fromTemplate(cppListLib)
}

task cppApplication(type: SourceCopyTask) {
    sampleDir = file("../cpp/application")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate(cppUtilsLib)
    appProject(".").fromTemplate(cppListLib)
}

task cppLibrary(type: SourceCopyTask) {
    sampleDir = file("../cpp/simple-library")

    libProject(".").fromTemplate(cppListLib)
}

task cppBinaryDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/binary-dependencies")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate(cppUtilsLib)
}

task cppPrebuiltBinaries(type: SourceCopyTask) {
    sampleDir = file("../cpp/prebuilt-binaries")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate(cppUtilsLib)
}

task cppCompositeBuild(type: SourceCopyTask) {
    sampleDir = file("../cpp/composite-build")

    appProject(".").fromTemplate("cpp-app")
    libProject("utilities-library").fromTemplate(cppUtilsLib)
    libProject("list-library").fromTemplate(cppListLib)
}

task cppSourceDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/source-dependencies")

    appProject(".").fromTemplate("cpp-app")
    libProject("repos/utilities").fromTemplate(cppUtilsLib)
    libProject("repos/list").fromTemplate(cppListLib)
}

task cppOSDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/operating-system-specific-dependencies")

    appProject("app").fromTemplate("cpp-app-uses-logger")
    appProject("app").fromTemplate(cppUtilsLib)
    appProject("app").fromTemplate(cppListLib)
    libProject("ansiLogger").fromTemplate(CppLibraryTemplate.of("cpp-ansi-logger-lib", "ansi_logger"))
    libProject("winConsoleLogger").fromTemplate(CppLibraryTemplate.of("cpp-windows-logger-lib", "win_logger"))
}

task cppStaticLibrary(type: SourceCopyTask) {
    sampleDir = file("../cpp/static-library")

    appProject("app").fromTemplate("cpp-app")
    staticLibProject("utilities").fromTemplate(cppUtilsLib)
    libProject("list").fromTemplate(cppListLib)
}

task cppSwiftPackageManager(type: SourceCopyTask) {
    sampleDir = file("../cpp/swift-package-manager")

    swiftPMProject(".", "App").fromTemplate("cpp-app")
    swiftPMProject(".", "Utilities").fromTemplate(cppUtilsLib)
    swiftPMProject(".", "List").fromTemplate(cppListLib)
}

task swiftApplication(type: SourceCopyTask) {
    sampleDir = file("../swift/application")

    appProject(".").fromTemplate("swift-app")
    appProject(".").fromTemplate(swiftUtilsLib)
    appProject(".").fromTemplate(swiftListLib)
}

task swiftApplicationOSDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/operating-system-specific-dependencies")

    appProject("app").fromTemplate("swift-app-uses-logger")
    appProject("app").fromTemplate(swiftUtilsLib)
    appProject("app").fromTemplate(swiftListLib)

    libProject("linux-logger").fromTemplate(SwiftLibraryTemplate.of("swift-blue-logger-lib", "LinuxLogger"))
    libProject("macos-logger").fromTemplate(SwiftLibraryTemplate.of("swift-green-logger-lib", "MacOsLogger"))
}

task swiftVersions(type: SourceCopyTask) {
    sampleDir = file("../swift/swift-versions")

    appProject("swift3-app").fromTemplate("swift-app")
    appProject("swift3-app").fromTemplate(SwiftLibraryTemplate.of("swift3-lib-with-api-dep", "Utilities"))
    appProject("swift3-app").fromTemplate(swiftListLib)

    appProject("swift4-app").fromTemplate("swift-app")
    appProject("swift4-app").fromTemplate(SwiftLibraryTemplate.of("swift4-lib-with-api-dep", "Utilities"))
    appProject("swift4-app").fromTemplate(swiftListLib)
}

task swiftSimpleLibrary(type: SourceCopyTask) {
    sampleDir = file("../swift/simple-library")

    libProject(".").fromTemplate(swiftListLib)
}

task swiftPrebuiltBinaries(type: SourceCopyTask) {
    sampleDir = file("../swift/prebuilt-binaries")

    appProject(".").fromTemplate("swift-app")
    appProject(".").fromTemplate(swiftUtilsLib)
}

task swiftTransitiveDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/transitive-dependencies")

    appProject("app").fromTemplate("swift-app")
    libProject("utilities").fromTemplate(swiftUtilsLib)
    libProject("list").fromTemplate(swiftListLib)
}

task swiftCompositeBuild(type: SourceCopyTask) {
    sampleDir = file("../swift/composite-build")

    appProject(".").fromTemplate("swift-app")
    libProject("utilities-library").fromTemplate(swiftUtilsLib)
    libProject("list-library").fromTemplate(swiftListLib)
}

task swiftSourceDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/source-dependencies")

    appProject(".").fromTemplate("swift-app")
    libProject("repos/utilities").fromTemplate(swiftUtilsLib)
    libProject("repos/list").fromTemplate(swiftListLib)
}

task swiftStaticLibrary(type: SourceCopyTask) {
    sampleDir = file("../swift/static-library")

    appProject("app").fromTemplate("swift-app")
    libProject("utilities").fromTemplate(swiftUtilsLib)
    libProject("list").fromTemplate(swiftListLib)
}

task swiftCppDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/cpp-dependencies")

    staticLibProject("list").fromTemplate("cpp-lib-with-c-api")
    appProject("app").fromTemplate(SwiftLibraryTemplate.of("swift-lib-uses-c-api", "List"))
    appProject("app").fromTemplate(swiftUtilsLib)
    appProject("app").fromTemplate("swift-app")
}

task swiftSwiftPackageManager(type: SourceCopyTask) {
    sampleDir = file("../swift/swift-package-manager")

    swiftPMProject(".", "App").fromTemplate("swift-app")
    swiftPMProject(".", "Utilities").fromTemplate(swiftUtilsLib)
    swiftPMProject(".", "List").fromTemplate(swiftListLib)
}

void changeContent(File srcFile, String pattern, String replacement) {
    def original = srcFile.text
    srcFile.text = original.replace(pattern, replacement)
}

task generateCppRepos(type: GitRepoTask) {
    sampleDir = file("../cpp/source-dependencies/repos")
    listChanges["1.0"] = { destDir ->
        changeContent(new File(destDir, "src/main/cpp/get.cpp"), "index > 0", "index > 1")
        "introduce bug in get.cpp"
    }
    listChanges["2.0"] = { destDir ->
        changeContent(new File(destDir, "src/main/cpp/get.cpp"), "index > 1", "index > 0")
        "fix bug in get.cpp"
    }
    utilitiesChanges["1.0"] = { "" }
    utilitiesChanges["2.0"] = { destDir ->
        changeContent(new File(destDir, "build.gradle"), "list:1.0", "list:2.0")
        "use list:2.0 as a dependency"
    }
}

task generateSwiftRepos(type: GitRepoTask) {
    sampleDir = file("../swift/source-dependencies/repos")
    listChanges["1.0"] = { destDir ->
        changeContent(new File(destDir, "src/main/swift/LinkedList.swift"), "c > 0", "c > 1")
        "introduce bug in LinkedList"
    }
    listChanges["2.0"] = { destDir ->
        changeContent(new File(destDir, "src/main/swift/LinkedList.swift"), "c > 1", "c > 0")
        "fix bug in LinkedList"
    }
    utilitiesChanges["1.0"] = { "" }
    utilitiesChanges["2.0"] = { destDir ->
        changeContent(new File(destDir, "build.gradle"), "list:1.0", "list:2.0")
        "use list:2.0 as a dependency"
    }
}

class SourceCopyTask extends DefaultTask {
    final DirectoryProperty sampleDir = project.layout.directoryProperty()
    final DirectoryProperty templatesDir = project.layout.directoryProperty()
    final Map<String, TemplateTarget> projects = [:]

    @TaskAction
    def go() {
        def cleaned = new HashSet()
        projects.values().each { p ->
            def modules = p.includedModules.collect { "import $it" as String }
            def testModules = p.includedModules.collect { "@testable import $it" as String }
            p.visitDirs { src, dest, lineFilter ->
                def srcDir = templatesDir.dir(src).get().asFile
                if (!srcDir.directory) {
                    return
                }
                def destDir = sampleDir.dir(dest).get().asFile
                println "copy $srcDir to $destDir"
                if (cleaned.add(destDir)) {
                    // TODO - generate the test main.swift
                    project.delete project.fileTree(destDir, { exclude '**/main.swift' })
                }
                project.copy {
                    from srcDir
                    into destDir
                    if (lineFilter) {
                        filter(lineFilter)
                    }
                    filter { line ->
                        if (modules.contains(line)) {
                            return null
                        }
                        if (testModules.contains(line)) {
                            return "@testable import " + p.module
                        }
                        line
                    }
                }
            }
        }
    }

    AppTarget appProject(String projectDir) {
        return add(new AppTarget(projectDir))
    }

    LibTarget libProject(String projectDir) {
        return add(new LibTarget(projectDir))
    }

    StaticLibTarget staticLibProject(String projectDir) {
        return add(new StaticLibTarget(projectDir))
    }

    SwiftPmTarget swiftPMProject(String projectDir, String targetName) {
        return add(new SwiftPmTarget(projectDir, targetName))
    }

    private def add(TemplateTarget target) {
        if (projects.containsKey(target.key)) {
            return projects.get(target.projectDir)
        }
        projects.put(target.key, target)
        return target
    }

    static abstract class TemplateTarget {
        final List<Template> templates = []
        final String projectDir

        TemplateTarget(String projectDir) {
            this.projectDir = projectDir
        }

        TemplateTarget fromTemplate(String templateName) {
            return fromTemplate(Template.of(templateName))
        }

        TemplateTarget fromTemplate(Template template) {
            templates.add(template)
            return this
        }

        String getModule() {
            def libs = templates.findAll { it instanceof SwiftLibraryTemplate }
            return libs.first().module
        }

        List<String> getIncludedModules() {
            def libs = templates.findAll { it instanceof SwiftLibraryTemplate }
            return libs.collect { it.module }
        }

        abstract String getKey()

        /**
         * Visits each src, dest directory pair for this project.
         * @param cl
         */
        void visitDirs(Closure cl) {
            templates.each { template ->
                visitDirMappings(template) { src, dest, lineFilter ->
                    cl.call("${template.templateName}/${src}", "${projectDir}/${dest}", lineFilter)
                }
            }
        }

        Closure addDllExportToPublicHeader(Template template) {
            if (template instanceof CppLibraryTemplate) {
                def macroName = template.name.toUpperCase() + "_API"
                def exportMacroName = template.name.toUpperCase() + "_MODULE_EXPORT"
                def macroDef = "#define ${macroName}"

                return { line ->
                    if (line == macroDef) {
                        return """
#ifdef _WIN32
#  ifdef ${exportMacroName}
#    define ${macroName} __declspec(dllexport)
#  else
#    define ${macroName} __declspec(dllimport)
#  endif
#else
#  define ${macroName}
#endif                        
""".trim()
                    }
                    return line
                }
            }
            return null
        }

        /**
         * Visits each candidate src, dest directory pair for this project and the given template.
         */
        abstract void visitDirMappings(Template template, Closure cl)
    }

    static abstract class GradleTarget extends TemplateTarget {
        GradleTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        String getKey() {
            return projectDir
        }
    }

    static class AppTarget extends GradleTarget {
        AppTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        String getModule() {
            return "App"
        }

        @Override
        void visitDirMappings(Template template, Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp", null)
            cl.call("src/main/headers", "src/main/headers", null)
            cl.call("src/main/public", "src/main/headers", null)
            cl.call("src/main/swift", "src/main/swift", null)
            cl.call("src/test/swift", "src/test/swift", null)
        }
    }

    static class LibTarget extends GradleTarget {
        LibTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        void visitDirMappings(Template template, Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp", null)
            cl.call("src/main/headers", "src/main/headers", null)
            cl.call("src/main/public", "src/main/public", addDllExportToPublicHeader(template))
            cl.call("src/main/swift", "src/main/swift", null)
            cl.call("src/test/swift", "src/test/swift", null)
        }
    }

    static class StaticLibTarget extends GradleTarget {
        StaticLibTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        void visitDirMappings(Template template, Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp", null)
            cl.call("src/main/headers", "src/main/headers", null)
            cl.call("src/main/public", "src/main/public", null)
            cl.call("src/main/swift", "src/main/swift", null)
            cl.call("src/test/swift", "src/test/swift", null)
        }
    }

    static class SwiftPmTarget extends TemplateTarget {
        final String targetName

        SwiftPmTarget(String projectDir, String targetName) {
            super(projectDir)
            this.targetName = targetName
        }

        @java.lang.Override
        String getModule() {
            return targetName
        }

        @java.lang.Override
        String getKey() {
            return "$projectDir:$targetName"
        }

        @java.lang.Override
        void visitDirMappings(Template template, Closure cl) {
            cl.call("src/main/cpp", "Sources/${targetName}", null)
            cl.call("src/main/headers", "Sources/${targetName}/include", null)
            cl.call("src/main/public", "Sources/${targetName}/include", addDllExportToPublicHeader(template))
            cl.call("src/main/swift", "Sources/${targetName}", null)
            cl.call("src/test/swift", "Tests/${targetName}Tests", null)
        }
    }
}

class Template {
    final String templateName

    Template(String templateName) {
        this.templateName = templateName
    }

    static of(String templateName) {
        return new Template(templateName)
    }
}

class SwiftLibraryTemplate extends Template {
    final String module

    SwiftLibraryTemplate(String templateName, String module) {
        super(templateName)
        this.module = module
    }

    static of(String templateName, String module) {
        return new SwiftLibraryTemplate(templateName, module)
    }
}

class CppLibraryTemplate extends Template {
    final String name

    CppLibraryTemplate(String templateName, String name) {
        super(templateName)
        this.name = name
    }

    static of(String templateName, String name) {
        return new CppLibraryTemplate(templateName, name)
    }
}

class GitRepoTask extends DefaultTask {
    final DirectoryProperty sampleDir = project.layout.directoryProperty()

    Map<String, Closure> utilitiesChanges = [:]
    Map<String, Closure> listChanges = [:]

    @TaskAction
    def go() {
        createRepo("utilities", utilitiesChanges)
        createRepo("list", listChanges)
    }

    private void createRepo(String sourceRepo, Map<String, Closure> changes) {
        def srcDir = sampleDir.dir(sourceRepo).get().asFile
        def destDir = sampleDir.dir(sourceRepo + "-repo").get().asFile
        project.delete(destDir)
        InitCommand init = Git.init();
        Git git = init.setDirectory(destDir).call()
        try {
            def files = []
            project.copy {
                from srcDir
                into destDir
                eachFile { d -> files.add(d.relativePath) }
            }
            def add = git.add()
            files.each {
                add.addFilepattern(it.pathString)
            }
            add.call()
            git.commit().setMessage("Initial version").call()
            changes.each { tag, change ->
                def message = change(destDir)
                git.commit().setAll(true).setMessage(message).call()
                git.tag().setName(tag).call()
            }
            
            // Uninteresting change just to have another commit
            new File(destDir, "build.gradle") << "\n"
            git.commit().setAll(true).setMessage("last commit").call()
        } finally {
            git.close()
        }
    }
}
