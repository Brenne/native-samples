import groovy.io.FileType
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.InitCommand

buildscript {
    dependencies {
        classpath "org.eclipse.jgit:org.eclipse.jgit:4.9.1.201712030800-r"
    }
}

plugins {
    id "groovy"
    id "idea"
}

repositories {
    jcenter()
}

dependencies {
    testImplementation gradleTestKit()
    testImplementation localGroovy()
    testImplementation("org.spockframework:spock-core:1.1-groovy-2.4") {
        exclude group: "org.codehaus.groovy"
    }
}

test {
    inputs.files files("../swift", '../cpp').asFileTree.matching { PatternFilterable pattern ->
        pattern.exclude "**/build", "**/.gradle", "**/*.xcworkspace", "**/*.xcodeproj", "**/repo"
    }
}

task cleanRepo(type: Delete) {
    delete file("../cpp/repo")
}

task cleanSamples {
    dependsOn cleanRepo
    doLast {
        def toDelete = []
        [file("../swift"), file("../cpp")]*.eachFileRecurse(FileType.DIRECTORIES) { def dir ->
            if ([/repo/, /build/, /\.gradle/, /.+\.xcworkspace/, /.+\.xcodeproj/].any { dir.name ==~ it }) {
                toDelete << dir
            }
        }
        toDelete.each { it.deleteDir() }
    }
}

clean.dependsOn cleanSamples

task configureNightlyWrapper {
    doLast {
        configure(tasks.nightlyWrapper) {
            def version = new groovy.json.JsonSlurper().parseText(new URL("https://services.gradle.org/versions/nightly").text)
            if (version.empty) {
                throw new GradleException("Cannot update wrapper to 'nightly' version as there is currently no version of that label")
            }
            println "updating wrapper to nightly version: $version.version (downloadUrl: $version.downloadUrl)"
            distributionUrl version.downloadUrl
        }
    }
}

task nightlyWrapper(type: Wrapper) {
    dependsOn configureNightlyWrapper
    group = "wrapper"
    description = "Updates the samples to use the most recent nightly"
    scriptFile = "../gradlew"
    jarFile = "../gradle/wrapper/gradle-wrapper.jar"
}

tasks.withType(SourceCopyTask) {
    templatesDir = file("src/templates")
    group = "source generation"
}

task generateSource {
    dependsOn tasks.withType(SourceCopyTask)
    group = "source generation"
    description = "generate the source files for all samples"
}

task cppTransitiveDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/transitive-dependencies")

    appProject("app").fromTemplate("cpp-app")
    libProject("utilities").fromTemplate("cpp-lib-with-api-dep")
    libProject("list").fromTemplate("cpp-lib")
}

task cppApplication(type: SourceCopyTask) {
    sampleDir = file("../cpp/application")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate("cpp-lib-with-api-dep")
    appProject(".").fromTemplate("cpp-lib")
}

task cppLibrary(type: SourceCopyTask) {
    sampleDir = file("../cpp/simple-library")

    libProject(".").fromTemplate("cpp-lib")
}

task cppBinaryDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/binary-dependencies")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate("cpp-lib-with-api-dep")
}

task cppPrebuiltBinaries(type: SourceCopyTask) {
    sampleDir = file("../cpp/prebuilt-binaries")

    appProject(".").fromTemplate("cpp-app")
    appProject(".").fromTemplate("cpp-lib-with-api-dep")
}

task cppCompositeBuild(type: SourceCopyTask) {
    sampleDir = file("../cpp/composite-build")

    appProject(".").fromTemplate("cpp-app")
    libProject("utilities-library").fromTemplate("cpp-lib-with-api-dep")
    libProject("list-library").fromTemplate("cpp-lib")
}

task cppSourceDependencies(type: SourceCopyTask) {
    sampleDir = file("../cpp/source-dependencies")

    appProject(".").fromTemplate("cpp-app")
    libProject("repos/utilities").fromTemplate("cpp-lib-with-api-dep")
    libProject("repos/list").fromTemplate("cpp-lib")
}

task cppSwiftPackageManager(type: SourceCopyTask) {
    sampleDir = file("../cpp/swift-package-manager")

    swiftPMProject("Sources/App").fromTemplate("cpp-app")
    swiftPMProject("Sources/Utilities").fromTemplate("cpp-lib-with-api-dep")
    swiftPMProject("Sources/List").fromTemplate("cpp-lib")
}

def swiftUtilsLib = SwiftLibraryTemplate.of("swift-lib-with-api-dep", "Utilities")
def swiftListLib = SwiftLibraryTemplate.of("swift-lib", "List")

task swiftApplication(type: SourceCopyTask) {
    sampleDir = file("../swift/application")

    appProject(".").fromTemplate("swift-app")
    appProject(".").fromTemplate(swiftUtilsLib)
    appProject(".").fromTemplate(swiftListLib)
}

task swiftSimpleLibrary(type: SourceCopyTask) {
    sampleDir = file("../swift/simple-library")

    libProject(".").fromTemplate(swiftListLib)
}

task swiftPrebuiltBinaries(type: SourceCopyTask) {
    sampleDir = file("../swift/prebuilt-binaries")

    appProject(".").fromTemplate("swift-app")
    appProject(".").fromTemplate(swiftUtilsLib)
}

task swiftTransitiveDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/transitive-dependencies")

    appProject("app").fromTemplate("swift-app")
    libProject("utilities").fromTemplate(swiftUtilsLib)
    libProject("list").fromTemplate(swiftListLib)
}

task swiftCompositeBuild(type: SourceCopyTask) {
    sampleDir = file("../swift/composite-build")

    appProject(".").fromTemplate("swift-app")
    libProject("utilities-library").fromTemplate(swiftUtilsLib)
    libProject("list-library").fromTemplate(swiftListLib)
}

task swiftSourceDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/source-dependencies")

    appProject(".").fromTemplate("swift-app")
    libProject("repos/utilities").fromTemplate(swiftUtilsLib)
    libProject("repos/list").fromTemplate(swiftListLib)
}

task swiftStaticLibrary(type: SourceCopyTask) {
    sampleDir = file("../swift/static-library")

    appProject("app").fromTemplate("swift-app")
    libProject("utilities").fromTemplate(swiftUtilsLib)
    libProject("list").fromTemplate(swiftListLib)
}

task swiftCppDependencies(type: SourceCopyTask) {
    sampleDir = file("../swift/cpp-dependencies")

    libProject("list").fromTemplate("cpp-lib-with-c-api")
    appProject("app").fromTemplate(SwiftLibraryTemplate.of("swift-lib-uses-c-api", "List"))
    appProject("app").fromTemplate(swiftUtilsLib)
    appProject("app").fromTemplate("swift-app")
}

task generateCppRepos(type: GitRepoTask) {
    sampleDir = file("../cpp/source-dependencies/repos")
}

task generateSwiftRepos(type: GitRepoTask) {
    sampleDir = file("../swift/source-dependencies/repos")
}

class SourceCopyTask extends DefaultTask {
    final DirectoryProperty sampleDir = project.layout.directoryProperty()
    final DirectoryProperty templatesDir = project.layout.directoryProperty()
    final Map<String, TemplateTarget> projects = [:]

    @TaskAction
    def go() {
        def cleaned = new HashSet()
        projects.values().each { p ->
            def projectDir = sampleDir.dir(p.projectDir).get().asFile
            def modules = p.includedModules.collect { "import $it" as String }
            def testModules = p.includedModules.collect { "@testable import $it" as String }
            p.templates.each { t ->
                def templateBaseDir = templatesDir.dir(t.templateName).get().asFile
                p.visitDirs { s, d ->
                    def srcDir = new File(templateBaseDir, s)
                    if (!srcDir.directory) {
                        return
                    }
                    def destDir = new File(projectDir, d)
                    println "copy $srcDir to $destDir"
                    if (cleaned.add(destDir)) {
                        // TODO - generate the test main.swift
                        project.delete project.fileTree(destDir, { exclude '**/main.swift' })
                    }
                    project.copy {
                        from srcDir
                        into destDir
                        filter { line ->
                            if (modules.contains(line)) {
                                return null
                            }
                            if (testModules.contains(line)) {
                                return "@testable import " + p.module
                            }
                            line
                        }
                    }
                }
            }
        }
    }

    AppTarget appProject(String projectDir) {
        return add(new AppTarget(projectDir))
    }

    LibTarget libProject(String projectDir) {
        return add(new LibTarget(projectDir))
    }

    SwiftPmTarget swiftPMProject(String projectDir) {
        return add(new SwiftPmTarget(projectDir))
    }

    private def add(TemplateTarget target) {
        if (projects.containsKey(target.projectDir)) {
            return projects.get(target.projectDir)
        }
        projects.put(target.projectDir, target)
        return target
    }

    static abstract class TemplateTarget {
        final List<Template> templates = []
        final String projectDir

        TemplateTarget(String projectDir) {
            this.projectDir = projectDir
        }

        TemplateTarget fromTemplate(String templateName) {
            return fromTemplate(Template.of(templateName))
        }

        TemplateTarget fromTemplate(Template template) {
            templates.add(template)
            return this
        }

        String getModule() {
            def libs = templates.findAll { it instanceof SwiftLibraryTemplate }
            return libs.first().module
        }

        List<String> getIncludedModules() {
            def libs = templates.findAll { it instanceof SwiftLibraryTemplate }
            return libs.collect { it.module }
        }

        abstract void visitDirs(Closure cl)
    }

    static class AppTarget extends TemplateTarget {
        AppTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        String getModule() {
            return "App"
        }

        @Override
        void visitDirs(Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp")
            cl.call("src/main/headers", "src/main/headers")
            cl.call("src/main/public", "src/main/headers")
            cl.call("src/main/swift", "src/main/swift")
            cl.call("src/test/swift", "src/test/swift")
        }
    }

    static class LibTarget extends TemplateTarget {
        LibTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        void visitDirs(Closure cl) {
            cl.call("src/main/cpp", "src/main/cpp")
            cl.call("src/main/headers", "src/main/headers")
            cl.call("src/main/public", "src/main/public")
            cl.call("src/main/swift", "src/main/swift")
            cl.call("src/test/swift", "src/test/swift")
        }
    }

    static class SwiftPmTarget extends TemplateTarget {
        SwiftPmTarget(String projectDir) {
            super(projectDir)
        }

        @Override
        void visitDirs(Closure cl) {
            cl.call("src/main/cpp", ".")
            cl.call("src/main/headers", "include")
            cl.call("src/main/public", "include")
            cl.call("src/main/swift", ".")
            cl.call("src/test/swift", "Test")
        }
    }
}

class Template {
    final String templateName

    Template(String templateName) {
        this.templateName = templateName
    }

    static of(String templateName) {
        return new Template(templateName)
    }
}

class SwiftLibraryTemplate extends Template {
    final String module

    SwiftLibraryTemplate(String templateName, String module) {
        super(templateName)
        this.module = module
    }

    static of(String templateName, String module) {
        return new SwiftLibraryTemplate(templateName, module)
    }
}

class GitRepoTask extends DefaultTask {
    final DirectoryProperty sampleDir = project.layout.directoryProperty()

    @TaskAction
    def go() {
        createRepo("utilities")
        createRepo("list")
    }

    private void createRepo(String sourceRepo) {
        def srcDir = sampleDir.dir(sourceRepo).get().asFile
        def destDir = sampleDir.dir(sourceRepo + "-repo").get().asFile
        project.delete(destDir)
        InitCommand init = Git.init();
        Git git = init.setDirectory(destDir).call()
        try {
            def files = []
            project.copy {
                from srcDir
                into destDir
                eachFile { d -> files.add(d.relativePath) }
            }
            def add = git.add()
            files.each {
                add.addFilepattern(it.pathString)
            }
            add.call()
            git.commit().setMessage("Initial version").call()
            git.tag().setName("1.0").call()
            new File(destDir, "build.gradle") << "\n"
            git.commit().setAll(true).setMessage("Initial version").call()
            git.tag().setName("2.0").call()
        } finally {
            git.close()
        }
    }
}
